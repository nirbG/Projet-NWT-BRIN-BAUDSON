"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Joi = require("joi");
const enums_1 = require("../lib/enums");
const entity_1 = require("../lib/entity");
const symbols_1 = require("../lib/symbols");
class JoiTransformer {
    constructor() {
        this.objectIdRegex = /^[0-9a-fA-F]{24}$/;
    }
    build(source, opts, more = Joi.object(), parent) {
        opts.unknown = opts.unknown === undefined || opts.unknown === null ? true : opts.unknown;
        const result = !source ? undefined : more.concat(this.reduceSchema(source.map(_ => this.propertyHandler(_, opts.mode, opts.unknown)), opts.unknown, !!parent ? parent.schema(opts) : undefined));
        if (!!opts.array) {
            return Joi.array().items(result);
        }
        return result;
    }
    isValid(data, schema) {
        return !!data && !Joi.validate(data, schema, {
            stripUnknown: true,
            convert: false
        }).error;
    }
    validate(data, schema) {
        return Joi.validate(data, schema, {
            stripUnknown: true,
            convert: false
        });
    }
    /**
     * Merge all rules and
     * reduce to an Object Schema
     *
     * @param  {PropertySchema[]} source
     * @returns Joi.ObjectSchema
     */
    reduceSchema(source, unknown, parent) {
        const _s = !!parent ? parent : Joi.object();
        const res = _s.keys(source
            .map(_ => ({
            property: _.property,
            schema: _.schemas.reduce((acc, cur) => acc.concat(cur), _.base)
        }))
            .reduce((acc, cur) => {
            acc[cur.property] = cur.schema;
            return acc;
        }, {}));
        return !!unknown ? res.unknown() : res;
    }
    /**
     * Property handler
     * Get the base schema
     * and map all rules in joi schema
     *
     * @param  {PropertyMetadata} source
     * @param  {ModeEnum} mode
     * @returns PropertySchema
     */
    propertyHandler(source, mode, unknown) {
        const base = source
            .rules
            .filter(_ => _.key === symbols_1.decorators.KEY_TYPE || _.key === symbols_1.decorators.KEY_ARRAY || _.key === symbols_1.decorators.KEY_OBJECT_PATTERN)
            .map(_ => this.ruleHandler(_, mode, unknown))
            .shift() || Joi.any();
        return {
            property: source.property,
            base,
            schemas: source
                .rules
                .filter(_ => (_.key !== symbols_1.decorators.KEY_TYPE && _.key !== symbols_1.decorators.KEY_ARRAY && _.key !== symbols_1.decorators.KEY_OBJECT_PATTERN))
                .map(_ => this.ruleHandler(_, mode, unknown, base))
                .filter(_ => !!_)
        };
    }
    /**
     * Rule handler
     * Call the right mapper for
     * a decorator's key
     *
     * @param  {PropertyRule} rule
     * @param  {ModeEnum} mode
     * @param  {Joi.Schema} base
     * @returns Joi.Schema
     */
    ruleHandler(rule, mode, unknown, base) {
        switch (rule.key) {
            case symbols_1.decorators.KEY_TYPE:
                return this.typeMapper(rule, mode, unknown);
            case symbols_1.decorators.KEY_ARRAY:
                return Joi.array().items(this.typeMapper(rule, mode, unknown));
            case symbols_1.decorators.KEY_REQUIRED:
                return this.requireMapper(rule, mode);
            case symbols_1.decorators.KEY_STRIP:
                return this.stripMapper(rule, mode, base);
            case symbols_1.decorators.KEY_VALID:
                return this.validMapper(rule);
            case symbols_1.decorators.KEY_INVALID:
                return this.invalidMapper(rule);
            case symbols_1.decorators.KEY_ALLOW:
                return this.allowMapper(rule);
            case symbols_1.decorators.KEY_DESCRIPTION:
                return this.descriptionMapper(rule);
            case symbols_1.decorators.KEY_MIN:
                return this.minMapper(rule, base);
            case symbols_1.decorators.KEY_MAX:
                return this.maxMapper(rule, base);
            case symbols_1.decorators.KEY_LENGTH:
                return this.lengthMapper(rule, base);
            case symbols_1.decorators.KEY_OBJECT_PATTERN:
                return this.objectPatternMapper(rule, unknown);
            case symbols_1.decorators.KEY_REGEX:
                return this.regexMapper(rule);
            /* istanbul ignore next */
            default:
                return Joi.any();
        }
    }
    /**
     * Type mapping
     *
     * @param  {PropertyRule} rule
     * @returns Joi.Schema
     */
    typeMapper(rule, mode, unknown) {
        switch (rule.value) {
            case String:
                return Joi.string();
            case Number:
                return Joi.number();
            case Boolean:
                return Joi.boolean();
            case Object:
                return unknown ? Joi.object().unknown() : Joi.object();
            case Buffer:
                return Joi.binary();
            case Date:
                return Joi.date();
            case enums_1.TypeEnum.Hex:
                return Joi.string().hex();
            case enums_1.TypeEnum.Base64:
                return Joi.string()['base64']();
            case enums_1.TypeEnum.IsoDate:
                return Joi.string().isoDate();
            case enums_1.TypeEnum.ObjectId:
                return Joi.string().regex(this.objectIdRegex);
            case enums_1.TypeEnum.Integer:
                return Joi.number().integer();
            case enums_1.TypeEnum.IP:
                return Joi.string().ip();
            case enums_1.TypeEnum.URI:
                return Joi.string().uri();
            case enums_1.TypeEnum.Email:
                return Joi.string().email();
            case enums_1.TypeEnum.Timestamp:
                return Joi.date().timestamp();
            /* istanbul ignore next */
            default:
                if (typeof rule.value === 'function' && new rule.value(null, { strict: false }) instanceof entity_1.BaseEntity) {
                    return rule.value.schema(mode);
                }
                return Joi.any();
        }
    }
    /**
     * Require mapping
     *
     * @param  {PropertyRule} rule
     * @param  {ModeEnum} mode
     * @returns Joi.Schema
     */
    requireMapper(rule, mode) {
        return []
            .concat(rule.value)
            .map(_ => _)
            .filter(_ => !!_ && _ === mode)
            .map(_ => Joi.any().required())
            .shift();
    }
    /**
     * Strip mapping
     *
     * @param  {PropertyRule} rule
     * @param  {ModeEnum} mode
     * @returns Joi.Schema
     */
    stripMapper(rule, mode, base) {
        return []
            .concat(rule.value)
            .map(_ => _)
            .filter(_ => !!_ && _ === mode)
            .map(_ => Joi.any().strip())
            .shift();
    }
    /**
     * Valid mapping
     *
     * @param  {PropertyRule} rule
     * @returns Joi.Schema
     */
    validMapper(rule) {
        return Joi.any().valid([]
            .concat(rule.value)
            .map(_ => (_ instanceof entity_1.EntityRef) ? Joi.ref(_.ref) : _));
    }
    /**
     * Invalid mapping
     *
     * @param  {PropertyRule} rule
     * @returns Joi.Schema
     */
    invalidMapper(rule) {
        return Joi.any().invalid([]
            .concat(rule.value)
            .map(_ => (_ instanceof entity_1.EntityRef) ? Joi.ref(_.ref) : _));
    }
    /**
     * Allow mapping
     *
     * @param  {PropertyRule} rule
     * @returns Joi.Schema
     */
    allowMapper(rule) {
        return Joi.any().allow([]
            .concat(rule.value)
            .map(_ => (_ instanceof entity_1.EntityRef) ? Joi.ref(_.ref) : _));
    }
    /**
     * Description mapping
     *
     * @param  {PropertyRule} rule
     * @returns Joi.Schema
     */
    descriptionMapper(rule) {
        return Joi.any().description(rule.value);
    }
    /**
     * Min mapping
     *
     * @param  {PropertyRule} rule
     * @param  {Joi.Schema} base
     * @returns Joi.Schema
     */
    minMapper(rule, base) {
        switch (base['_type']) {
            case 'string':
                return Joi.string().min(rule.value);
            case 'number':
                return Joi.number().min(rule.value);
            case 'binary':
                return Joi.binary().min(rule.value);
            case 'array':
                return Joi.array().min(rule.value);
            default:
                return Joi.any();
        }
    }
    /**
     * Max mapping
     *
     * @param  {PropertyRule} rule
     * @param  {Joi.Schema} base
     * @returns Joi.Schema
     */
    maxMapper(rule, base) {
        switch (base['_type']) {
            case 'string':
                return Joi.string().max(rule.value);
            case 'number':
                return Joi.number().max(rule.value);
            case 'binary':
                return Joi.binary().max(rule.value);
            case 'array':
                return Joi.array().max(rule.value);
            default:
                return Joi.any();
        }
    }
    /**
     * Length mapping
     *
     * @param  {PropertyRule} rule
     * @param  {Joi.Schema} base
     * @returns Joi.Schema
     */
    lengthMapper(rule, base) {
        switch (base['_type']) {
            case 'string':
                return Joi.string().length(rule.value);
            case 'binary':
                return Joi.binary().length(rule.value);
            case 'array':
                return Joi.array().length(rule.value);
            default:
                return Joi.any();
        }
    }
    /**
     * Object Pattern mapping
     *
     * @param  {PropertyRule} rule
     * @returns Joi.Schema
     */
    objectPatternMapper(rule, unknown) {
        if (!rule.value.schema) {
            throw new Error('Wrong schema provided');
        }
        else if (rule.value.schema instanceof entity_1.BaseEntity) {
            return Joi.object().pattern(rule.value.pattern, rule.value.schema.schema());
        }
        else {
            return Joi.object().pattern(rule.value.pattern, this.typeMapper({ key: null, value: rule.value.schema }, enums_1.ModeEnum.READ, unknown));
        }
    }
    /**
     * Regex mapping
     *
     * @param  {PropertyRule} rule
     * @returns Joi.Schema
     */
    regexMapper(rule) {
        if (!(rule.value instanceof RegExp)) {
            throw new Error('Wrong regex provided');
        }
        else {
            return Joi.string().regex(rule.value);
        }
    }
}
exports.JoiTransformer = JoiTransformer;
//# sourceMappingURL=joi.transformer.js.map