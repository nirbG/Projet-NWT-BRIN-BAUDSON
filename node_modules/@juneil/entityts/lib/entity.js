"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const symbols_1 = require("./symbols");
const enums_1 = require("./enums");
const joi_transformer_1 = require("../transformers/joi.transformer");
class EntityRef {
    constructor(ref) {
        this.ref = ref;
    }
}
exports.EntityRef = EntityRef;
class BaseEntity {
    /**
     * Try to populate the Entity with
     * a provided payload
     *
     * @constructor
     * @param  {} payload={}
     */
    constructor(payload = {}, options) {
        options = options || { strict: true, mode: enums_1.ModeEnum.READ };
        payload = payload || {};
        options.unknown = false;
        const result = this
            .constructor['transformers'][0]
            .validate(payload, this.constructor['schema'](options));
        if (options.strict !== false && !!result.error) {
            throw result.error;
        }
        []
            .concat(Object.keys(result.value))
            .filter(_ => result.value[_] !== undefined)
            .forEach((_) => Reflect.set(this, _, result.value[_]));
    }
    static more() { }
    /**
     * Get schema
     * @todo Implement the transformers system
     * @param  {ModeEnum=ModeEnum.READ} mode
     * @returns T
     */
    static schema(opts) {
        if (Object.values(enums_1.ModeEnum).includes(opts)) {
            opts = { mode: opts };
        }
        else if (!opts) {
            opts = { mode: enums_1.ModeEnum.READ };
        }
        if (!(this.transformers && this.transformers.length > 0)) {
            return;
        }
        return this
            .transformers[0]
            .build(Reflect.getMetadata(symbols_1.KEY_PROPS, this), opts, this.more(), this.parent);
    }
    /**
     * Do a reference to another property
     *
     * @param  {string} ref
     * @returns EntityRef
     */
    static ref(ref) {
        return new EntityRef(ref);
    }
    /**
     * Check if the entity instance is valid
     *
     * @param  {ModeEnum=ModeEnum.READ} mode
     * @returns boolean
     */
    isValid(mode = enums_1.ModeEnum.READ) {
        return this
            .constructor['transformers'][0]
            .isValid(this, this.constructor['schema'](mode));
    }
    /**
     * Get schema
     *
     * @param  {ModeEnum} mode
     */
    schema(opts) {
        return this.constructor['schema'](opts);
    }
}
BaseEntity.Mode = enums_1.ModeEnum;
BaseEntity.Type = enums_1.TypeEnum;
exports.BaseEntity = BaseEntity;
/**
 * Mixin to link Tranformers
 *
 * @param  {Constructor<Object>[]} ...transformers
 */
function EntityTo(...transformers) {
    var _a;
    return _a = class extends BaseEntity {
            static more() { }
            ;
        },
        _a.transformers = transformers.map(Transformer => new Transformer()),
        _a.parent = undefined,
        _a;
}
exports.EntityTo = EntityTo;
exports.Entity = EntityTo(joi_transformer_1.JoiTransformer);
function EntityExtends(parent) {
    var _a;
    const _p = Reflect.construct(parent, [{}, { strict: false }]);
    if (!(_p instanceof BaseEntity)) {
        throw new Error('You need to extends another Entity');
    }
    return _a = class extends BaseEntity {
            static more() { }
            ;
        },
        _a.transformers = [new joi_transformer_1.JoiTransformer()],
        _a.parent = parent,
        _a;
}
exports.EntityExtends = EntityExtends;
//# sourceMappingURL=entity.js.map