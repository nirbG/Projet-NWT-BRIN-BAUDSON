"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const enums_1 = require("./enums");
const symbols_1 = require("./symbols");
const entity_1 = require("./entity");
/**
 * Decorator @Type()
 * Determine the property type
 * for validation
 *
 * @param  {PropertyType} type
 * @returns DecoratorFunc
 */
function Type(type) {
    return insertRule({ key: symbols_1.decorators.KEY_TYPE, value: type });
}
exports.Type = Type;
/**
 * Decorator @Array()
 * Determine the property type
 * for validation
 *
 * @param  {PropertyType} type
 * @returns DecoratorFunc
 */
function Array(type) {
    return insertRule({ key: symbols_1.decorators.KEY_ARRAY, value: type });
}
exports.Array = Array;
/**
 * Decorator @Required()
 * Set the requirement of the property
 *
 * @param  {ModeEnum[]} mode
 * @returns DecoratorFunc
 */
function Required(...mode) {
    mode = !mode.length ? [enums_1.ModeEnum.READ] : mode;
    return insertRule({ key: symbols_1.decorators.KEY_REQUIRED, value: mode });
}
exports.Required = Required;
/**
 * Decorator @Strip()
 * Determine if the property
 * should be removed
 *
 * @param  {ModeEnum[]} mode
 * @returns DecoratorFunc
 */
function Strip(...mode) {
    mode = !mode.length ? [enums_1.ModeEnum.READ] : mode;
    return insertRule({ key: symbols_1.decorators.KEY_STRIP, value: mode });
}
exports.Strip = Strip;
/**
 * Decorator @Valid()
 * Determine the values
 * allowed
 *
 * @param  {any[]} value
 * @returns DecoratorFunc
 */
function Valid(...value) {
    return insertRule({ key: symbols_1.decorators.KEY_VALID, value });
}
exports.Valid = Valid;
/**
 * Decorator @Invalid()
 * Determine the values
 * only allowed
 *
 * @param  {any[]} value
 * @returns DecoratorFunc
 */
function Invalid(...value) {
    return insertRule({ key: symbols_1.decorators.KEY_INVALID, value });
}
exports.Invalid = Invalid;
/**
 * Decorator @Allow()
 * Determine the values
 * allowed
 *
 * @param  {any[]} value
 * @returns DecoratorFunc
 */
function Allow(...value) {
    return insertRule({ key: symbols_1.decorators.KEY_ALLOW, value });
}
exports.Allow = Allow;
/**
 * Decorator @Description()
 * Describe the property
 *
 * @param  {string} description
 * @returns DecoratorFunc
 */
function Description(description) {
    return insertRule({ key: symbols_1.decorators.KEY_DESCRIPTION, value: description });
}
exports.Description = Description;
/**
 * Decorator @Min()
 * Set a min validation
 *
 * @param  {number} value
 * @returns DecoratorFunc
 */
function Min(value) {
    return insertRule({ key: symbols_1.decorators.KEY_MIN, value });
}
exports.Min = Min;
/**
 * Decorator @Max()
 * Set a max validation
 *
 * @param  {number} value
 * @returns DecoratorFunc
 */
function Max(value) {
    return insertRule({ key: symbols_1.decorators.KEY_MAX, value });
}
exports.Max = Max;
/**
 * Decorator @Length()
 * Set a length validation
 *
 * @param  {number} value
 * @returns DecoratorFunc
 */
function Length(value) {
    return insertRule({ key: symbols_1.decorators.KEY_LENGTH, value });
}
exports.Length = Length;
/**
 * Decorator @ObjectPattern()
 *
 * @param  {RegExp} pattern
 * @param  {PropertyType} schema
 * @returns DecoratorFunc
 */
function ObjectPattern(pattern, schema) {
    return insertRule({ key: symbols_1.decorators.KEY_OBJECT_PATTERN, value: { pattern, schema } });
}
exports.ObjectPattern = ObjectPattern;
/**
 * Decorator @Regex()
 *
 * @param  {RegExp} pattern
 * @returns DecoratorFunc
 */
function Regex(pattern) {
    return insertRule({ key: symbols_1.decorators.KEY_REGEX, value: pattern });
}
exports.Regex = Regex;
/**
 * Insert a new rule of a property
 * in the metadata of the Entity
 *
 * @param  {Function} target
 * @param  {string} propertyName
 * @param  {PropertyRule} rule
 * @returns void
 */
function insertRule(rule) {
    return function (target, propertyName) {
        if (!(target instanceof entity_1.BaseEntity)) {
            return;
        }
        Reflect
            .defineMetadata(symbols_1.KEY_PROPS, getPropertiesWithInit(target.constructor, propertyName)
            .map(_ => ({
            property: _.property,
            rules: _.property === propertyName ? _.rules.concat(rule) : _.rules
        })), target.constructor);
    };
}
/**
 * Get properties from metadata
 * and initialize property if does
 * not already exist
 *
 * @param  {Function} target
 * @param  {string} propertyName
 * @returns PropertyMetadata
 */
function getPropertiesWithInit(target, propertyName) {
    const props = []
        .concat(Reflect.getOwnMetadata(symbols_1.KEY_PROPS, target))
        .filter(_ => !!_);
    if (!props.find(_ => _.property === propertyName)) {
        return props.concat({ property: propertyName, rules: [] });
    }
    return props;
}
//# sourceMappingURL=decorators.js.map