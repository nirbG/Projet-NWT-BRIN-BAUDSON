"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Rx_1 = require("rxjs/Rx");
const logger_1 = require("../../core/logger");
class Socket {
    constructor(request, _connection, _rooms) {
        this.request = request;
        this._connection = _connection;
        this._rooms = _rooms;
        this.data$ = new Rx_1.Subject();
        this.store = {};
        this.on('close', data => this.data$.complete());
        this.on('error', err => this.data$.error(err));
        this.on('*', data => this.data$.next(this.getJSON(data.utf8Data)));
        Socket.logger.debug(`New socket... ${this.request.host}`);
    }
    /**
     * Listen events
     *
     * @param  {string} event
     * @param  {(data: any)=>void} callback
     */
    on(event, callback) {
        switch (event) {
            case '*':
                this._connection.on('message', callback);
                break;
            case 'close':
                this._connection.on(event, callback);
                break;
            case 'error':
                this._connection.on(event, callback);
                break;
            default:
                this._connection.on('message', message => {
                    if (message.type === 'utf8') {
                        const parsed = this.getJSON(message.utf8Data);
                        if (parsed.event === event) {
                            callback(parsed.data);
                        }
                    }
                });
        }
    }
    /**
     * Listen data filtered by event
     * in a Observable
     *
     * @param  {string} event
     * @returns Observable
     */
    on$(event) {
        return this
            .data$
            .filter(_ => _ && _.event === event)
            .map(_ => _.data);
    }
    /**
     * Listen to binary data
     *
     * @param  {(data:Buffer)=>void} callback
     */
    onBytes(callback) {
        this._connection.on('message', message => {
            if (message.type === 'binary') {
                callback(message.binaryData);
            }
        });
    }
    /**
     * Send data
     *
     * @param  {string} event
     * @param  {any} data
     */
    emit(event, data) {
        this._connection.sendUTF(JSON.stringify({
            event,
            data
        }));
    }
    /**
     * Send bytes
     *
     * @param  {Buffer} data
     */
    emitBytes(data) {
        this._connection.sendBytes(data);
    }
    /**
     * Close connection
     */
    close() {
        this._connection.close();
    }
    join(room) {
        this._rooms.join(room, this);
        /* Leave room when socket connection is closed */
        this.on('close', () => {
            this._rooms.leave(room, this);
        });
        return this;
    }
    leave(room) {
        this._rooms.leave(room, this);
        return this;
    }
    setData(key, value) {
        this.store[key] = value;
        return this;
    }
    getData(key) {
        return this.store[key];
    }
    getJSON(data) {
        try {
            return JSON.parse(data);
        }
        catch (e) {
            /* istanbul ignore next */
            return data;
        }
    }
}
Socket.logger = new logger_1.InternalLogger('module');
exports.Socket = Socket;
//# sourceMappingURL=socket.js.map